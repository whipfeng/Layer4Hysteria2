/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package Layer4Hysteria2 */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
extern size_t _GoStringLen(_GoString_ s);
extern const char *_GoStringPtr(_GoString_ s);
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 3 "main.go"





#include <stdio.h>
#include <stdlib.h>
#include <com_net_layer4_common_netty_channel_Hysteria2ProxyChannel.h>

static const char* GetJStringUTF(JNIEnv* env, jstring jstr) {
    if (jstr == NULL) return NULL;
    return (*env)->GetStringUTFChars(env, jstr, NULL);
}

static void ReleaseJStringUTF(JNIEnv* env, jstring jstr, const char* cstr) {
    if (cstr != NULL) {
        (*env)->ReleaseStringUTFChars(env, jstr, cstr);
    }
}

static jobject NewGlobalRef(JNIEnv* env, jobject obj) {
    jobject gobj = (*env)->NewGlobalRef(env, obj);
    return gobj;
}

static void DeleteGlobalRef(JNIEnv* env, jobject gobj) {
    (*env)->DeleteGlobalRef(env, gobj);
}

static JNIEnv* GetJNIEnv(JavaVM* jvm) {
    JNIEnv *env = NULL;
    if ((*jvm)->GetEnv(jvm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {
        (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);
    }
    return env;
}

static jmethodID GetMethodID(JNIEnv* env, jobject obj, const char *name, const char *sig) {
    jclass cls = (*env)->GetObjectClass(env, obj);
    jmethodID mid = (*env)->GetMethodID(env, cls, name, sig);
    return mid;
}

static jstring GetJMsg(JNIEnv* env, const char* errmsg) {
    jstring jmsg = NULL;
    if (errmsg != NULL) {
        jmsg = (*env)->NewStringUTF(env, errmsg);
    }
    return jmsg;
}

static void ReleaseObjs(JNIEnv* env, jobject obj, jstring jmsg) {
    if (jmsg != NULL) {
        (*env)->DeleteLocalRef(env, jmsg);
    }
    DeleteGlobalRef(env, obj);
}

static void callConnectResp(JavaVM* jvm, jobject obj, const char* errmsg, const long connectionId) {
    fprintf(stderr,"callConnectResp debug1\n");
    JNIEnv* env = GetJNIEnv(jvm);
    fprintf(stderr,"callConnectResp debug2\n");
    jstring jmsg = GetJMsg(env, errmsg);
    fprintf(stderr,"callConnectResp debug3\n");
    jmethodID mid = GetMethodID(env, obj, "connectResp", "(Ljava/lang/String;J)V");
    fprintf(stderr,"callConnectResp debug4\n");
    (*env)->CallVoidMethod(env, obj, mid, jmsg, (jlong)connectionId);
    fprintf(stderr,"callConnectResp debug5\n");
    ReleaseObjs(env, obj, jmsg);
}


#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#if !defined(__cplusplus) || _MSVC_LANG <= 201402L
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
#include <complex>
typedef std::complex<float> GoComplex64;
typedef std::complex<double> GoComplex128;
#endif
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif

extern jint JNI_OnLoad(JavaVM* vm, void* reserved);
extern void Java_com_net_layer4_common_netty_channel_Hysteria2ProxyChannel_connectReq(JNIEnv* env, jobject obj, jstring dhost, jint dport, jstring server, jstring password, jint port, jboolean skipcertverify, jstring sni, jboolean udp);

#ifdef __cplusplus
}
#endif
